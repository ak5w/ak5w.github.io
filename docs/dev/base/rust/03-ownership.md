[返回](/docs/dev/base/index.md)

[toc]

## 2. 所有权

所有权（系统）是 Rust 最为**与众不同**的特性，它让 Rust \*\*无需垃圾回收（garbage collector）即可保障内存安全。

`Rust`语言中的所有权系统是为了解决程序中使用堆内存后如何释放回收的问题的。在以往的其他语言中，有把内存回收的任务交给程序员负责的，如 `c/c++`语言，也有自带GC，无需程序开发者处理的，如`Java`, python等。

*   程序开发者处理内存回收问题的优缺点：
    *   优点：高性能
    *   缺点：需要极高的技术水平；存在安全隐患
*   自带 GC 处理断点优缺点：
    *   优点：开发效率高，技术认知门槛低
    *   缺点：存在性能稳定度问题，尤其 gc 处理时带来的程序`停滞`性，当然，目前的 gc 处理也在飞速进步。

为此，`Rust`语言中引入了一个 `变量所有权`的概念，结合变量生命周期以及编译器打入释放操作的方式来兼顾其他语言处理的优缺点，达到一个新的平衡。

1那所有权系统来解决内存回收除了认知门槛高之外，还有什么优缺点呢？在并发处理中会不会存在没有释放的情况呢？

我理解并发处理中，主要的问题在于**写操作**，只要能确保写操作是安全的情况时，就能解决绝大部分的并发问题了。

### 2.1 所有权

#### 所有权的转移

先看下面例子：

```rust
fn main() {

    // s3 是在栈上的内存
    let s3 = "hello stack.";
    {
        let s4 = s3;
        println!("s3 = {}, s4 = {}", s3, s4);
    } // s4 的作用域结束，未发生任何操作，栈内变量会随着栈的调用消亡而自动释放。
    println!("s3 = {}", s3);

    /////////////////////////////////////////////////////

    // s1 是从堆内存上申请而来，默认情况下，其作用域到本函数末尾结束。
    let s1 = String::from("hello heap.");
    {
        //let s2 = s1; // s1的所有权直接发生转移到 s2 持有，随即 s1 失效，编译器自动插入了 drop 
                     // 以至于 下面还要print s1 时遇到报错。
        let s2 = &s1;   // 此处进行了借用
        println!("s1 = {}, s2 = {}", s1, s2);
    }
    println!("s1 = {}", s1);
}
```

#### 所有权的不转移：引用

##### 可变与不可变引用

正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}
// &mut String 可变引用类型
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

可变引用有一个**很大的限制**：不能在同一个作用域内有多个可变引用，主要为了防止**数据竞争**

一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 **同时** 拥有：

```rust
    let mut s = String::from("hello");
    {
        let r1 = &mut s;
    } // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

    let r2 = &mut s;
```

引用的作用域

与其他变量相比较，引用的作用域结束是在其最后一次被使用后，立马结束的。如下代码是 `ok`的。

```rust
    let mut s = String::from("hello");

    let r1 = &s; // 没问题
    let r2 = &s; // 没问题
    println!("{} and {}", r1, r2);
    // 此位置之后 r1 和 r2 不再使用

    let r3 = &mut s; // 没问题
    println!("{}", r3);
```

我们将创建一个引用的行为称为 **借用**（*borrowing*）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。我们并不拥有它。

##### [引用的规则](https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#引用的规则)

让我们概括一下之前对引用的讨论：

*   在任意给定时间，**要么** 只能有一个可变引用，**要么** 只能有多个不可变引用。
*   引用必须总是有效的。

### 2.2 Slice 类型

*slice* 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。

TODO: <u>栈中的所有数据都必须占用已知且固定的大小</u>。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。?

栈中的所有数据都必须固定大小？为什么呢？如果栈空间足够大的话，为什么不可以像堆一样使用呢？

> 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。
